# 동시성과 관련된 기본 개념 및 ReentrantLock 채택 이유

---

## 1. 동시성

동시성(Concurrency)은 여러 작업이 동일한 자원에 동시에 접근하거나 수행될 때 발생하는 상황을 의미.
이는 멀티스레드, 다중 프로세스, 또는 분산 시스템 환경에서 주로 나타나며, 효율적인 시스템 운영을 위해 필수적으로 고려해야 하는 요소이다.

---

## 2. 동시성으로 인해 발생하는 문제

### 1) 데이터 무결성
- 여러 쓰레드가 동일한 데이터에 접근하고 수정할 경우, 데이터가 예상치 못한 상태로 변경될 수 있음
  - ex) 두 쓰레드가 동일한 사용자 포인트를 동시에 수정 할 경우, 값이 손실되거나 중복될 수 있음

### 2.2 데드락(Deadlock)
- 두 개 이상의 작업이 서로의 자원을 기다리며 무한 대기 상태가 됨

### 2.3 레이스 컨디션(Race Condition)
- 여러개의 프로세스가 공유 자원에 접근할 때 실행 순서가 보장되지 않을 경우, 실행 순서에 따라 결과 값이 달라질 수 있는 현상

### 2.4 성능 병목
- 지나치게 동시성 제어를 적용할 경우, 자원 접근이 제한되어 작업 처리 속도가 느려질 수 있음

---

## 3. 동시성 체크의 필요성

### 3.1 데이터의 정합성 보장
- 사용자가 동일한 데이터를 동시에 수정하는 상황에서도 데이터가 올바른 상태로 유지되어야 함

### 3.2 시스템 안정성 확보
- 예외적인 동작을 방지하여 시스템이 중단되지 않고 정상적으로 운영되어야 함

### 3.3 성능 최적화
- 불필요한 동시성 제어를 줄이고 필요한 경우에만 적용하여 성능을 유지

---

## 4. 여러 동시성 체크 방식과 채택 이유

### 4.1 동시성 체크 방식
1. **Synchronized**
   - 자바 기본 키워드로 간단하게 구현 가능
   - 단점: 동기화 블록 크기가 커질수록 성능 저하
   
2. **ReentrantLock**
   - 명시적 잠금 및 해제를 지원하며, 공정성 설정 등 기능 제공
   - 더 세밀한 동시성 제어 가능

3. **데이터베이스 트랜잭션**
   - 트랜잭션 범위 내에서 데이터 접근을 제어
   - 단점: 애플리케이션과 DB 간의 트랜잭션 처리 비용이 증가될할 수 있음

---

### 4.2  ReentrantLock과 ConcurrentHashMap의 조합 사용 이유

1. **세밀한 제어**
   - `lock()`과 `unlock()`을 명시적으로 호출하여 Synchronized와 달리 잠금 범위를 필요 최소한으로 설정 가능
   - 데이터 보호뿐만 아니라, 특정 로직에서 동기화 로직을 안전하게 실행할 수 있음

2. **유연성**
   - ReentrantLock은 읽기보다 쓰기(수정) 작업이 많은 상황에서 필요한 블록만 잠글 수 있어, ConcurrentHashMap은 읽기 작업이 많을 경우 ReentrantLock 없이도 성능을 유지할 수 있어 동시에 채택함
